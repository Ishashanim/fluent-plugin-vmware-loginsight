# Fluentd plugin for VMware Log Insight
# 
# Copyright 2018 VMware, Inc. All Rights Reserved. 
# 
# This product is licensed to you under the MIT license (the "License").  You may not use this product except in compliance with the MIT License.  
# 
# This product may include a number of subcomponents with separate copyright notices and license terms. Your use of these subcomponents is subject to the terms and conditions of the subcomponent's license, as noted in the LICENSE file. 
# 
# SPDX-License-Identifier: MIT


require "fluent/plugin/output"
require 'json'
require 'net/http'
require 'uri'

module Fluent
  module Plugin
    class Fluent::VmwareLoginsightOutput < Fluent::Output
      class ConnectionFailure < StandardError; end
    
      Fluent::Plugin.register_output('vmware_loginsight', self)
    
      ### Connection Params ###
      config_param :scheme, :string, :default => 'http'
      # Loginsight Host ex. localhost
      config_param :host, :string,  :default => 'localhost'
      # In case we want to post to  multiple hosts. This is futuristic, Fluentd copy plugin can support this as is
      #config_param :hosts, :string, :default => nil
      # Loginsight port ex. 9000. Default 80
      config_param :port, :integer, :default => 80
      # Loginsight ingestion api path ex. 'api/v1/events/ingest'
      config_param :path, :string, :default => 'api/v1/events/ingest'
      # agent_id generated by your LI
      config_param :agent_id, :string, :default => '0'
      # Credentials if used
      config_param :username, :string, :default => nil
      config_param :password, :string, :default => nil, :secret => true
      # Authentication nil | 'basic'
      config_param :authentication, :string, :default => nil
    
      # Set Net::HTTP.verify_mode to `OpenSSL::SSL::VERIFY_NONE`
      config_param :ssl_verify, :bool, :default => true
      config_param :ca_file, :string, :default => nil
    
      ### API Params ###
      # HTTP method
      # post | put
      config_param :http_method, :string, :default => :post
      # form | json
      config_param :serializer, :string, :default => :json
      config_param :request_retries, :integer, :default => 3
      config_param :request_timeout, :time, :default => 5
    
      # Simple rate limiting: ignore any records within `rate_limit_msec`
      # since the last one.
      config_param :rate_limit_msec, :integer, :default => 0
      # Raise errors that were rescued during HTTP requests?
      config_param :raise_on_error, :bool, :default => false
      ### Additional Params
      config_param :include_tag_key, :bool, :default => true
      # Metadata key that identifies Fluentd tags
      config_param :tag_key, :string, :default => 'tag'
      # Flatten hashes to create one key/val pair w/o losing log data
      config_param :flatten_hashes, :bool, :default => true
      # Seperator to use for joining flattened keys
      config_param :flatten_hashes_separator, :string, :default => "__"
    
    
      def initialize
        super
      end
    
      def configure(conf)
        super
    
        @ssl_verify_mode = @ssl_verify ? OpenSSL::SSL::VERIFY_PEER : OpenSSL::SSL::VERIFY_NONE
        @auth = case @authentication
                when 'basic'
                  :basic
                else
                  :none
                end
    
        @last_request_time = nil
      end
    
      def start
        super
      end
    
      def shutdown
        super
      end
    
      def format_url()
        url = "#{@scheme}://#{host}:#{port}/#{path}/#{agent_id}"
        url
      end
    
      def set_header(req)
        if @serializer == 'json'
          set_json_header(req)
        end
        req
      end
    
      def set_json_header(req)
        req['Content-Type'] = 'application/json'
        req
      end
    
      def set_body(req, tag, time, record)
        if @serializer == 'json'
          set_json_body(req, tag, time, record)
        end
        req
      end
    
      def set_json_body(req, tag, time, record)
        req.body = create_loginsight_events(tag, time, record).to_json
      end
    
      def create_loginsight_events(tag, time, record)
        flattened_records = {}
        if @flatten_hashes
          flattened_records = flatten_record(record, [])
        end
        flattened_records[@tag_key] = tag if @include_tag_key
        fields = []
        log = ''
        flattened_records.each do |key, value|
          next if value.nil?
          # LI doesn't allow some characters in field 'name'
          # like '/', '-', '\', '.', etc. so replace them with '__'
          key = key.gsub(/[\/\.\-\\]/,'__').downcase
          # LI needs to have field keys/values in utf-8 format
          key.force_encoding("utf-8")
          value.force_encoding("utf-8")
          if ['log', 'message', 'msg'].include?(key)
            if log != "#{value}"
              log += " #{value}"
            end
          else
            # If there is time information available, update time for LI. LI ignores
            # time if it is out of the error/adjusment window of 10 mins. in such
            # cases we would still like to preserve time info, so add it as event
            # TODO Ignore the below block for now. Handle the case for time being in 
            #      different formats than milliseconds
            #if ['time', '_source_realtime_timestamp'].include?(key)
            #  time = value
            #end
            fields << {"name" => key, "content" => value}
          end
        end
        events = {
          "events" => [{
            "fields" => fields,
            "text" => log,
            "timestamp" => time
          }]
        }
        events
      end
    
    
      def flatten_record(record, prefix=[])
        ret = {}
    
        case record
          when Hash
            record.each { |key, value|
              ret.merge! flatten_record(value, prefix + [key.to_s])
            }
          when Array
            # Don't mess with arrays, leave them unprocessed
            ret.merge!({prefix.join(@flatten_hashes_separator) => record})
          else
            return {prefix.join(@flatten_hashes_separator) => record}
        end
        ret
      end
    
      def create_request(tag, time, record)
        url = format_url()
        uri = URI.parse(url)
        req = Net::HTTP.const_get(@http_method.to_s.capitalize).new(uri.path)
        set_body(req, tag, time, record)
        set_header(req)
        return req, uri
      end
    
    
      def send_request(req, uri)
        is_rate_limited = (@rate_limit_msec != 0 and not @last_request_time.nil?)
        if is_rate_limited and ((Time.now.to_f - @last_request_time) * 1000.0 < @rate_limit_msec)
          $log.info('Dropped request due to rate limiting')
          return
        end
    
        if @auth and @auth == 'basic'
          req.basic_auth(@username, @password)
        end
        begin
          retries ||= 2
          response = nil
          @last_request_time = Time.now.to_f
    
          http_conn = Net::HTTP.new(uri.host, uri.port)
          # For debugging, set this
          #http_conn.set_debug_output($stdout)
          http_conn.use_ssl = (uri.scheme == 'https')
          if http_conn.use_ssl?
            http_conn.ca_file = @ca_file
          end
          http_conn.verify_mode = @ssl_verify_mode
    
          response = http_conn.start do |http|
            http.read_timeout = @request_timeout
            http.request(req)
          end
        rescue => e # rescue all StandardErrors
          # server didn't respond
          # Be careful while turning on below log, if LI instance can't be reached and you're sending
          # log-container logs to LI as well, you may end up in a cycle.
          # TODO handle the cyclic case at plugin level if possible.
          #$log.warn "Net::HTTP.#{req.method.capitalize} raises exception: " \
          #   "#{e.class}, '#{e.message}', \n Request: #{req.body}"
          retry unless (retries -= 1).zero?
          raise e if @raise_on_error
        else
           unless response and response.is_a?(Net::HTTPSuccess)
              res_summary = if response
                               "Response Code: #{response.code}\n"\
                               "Response Message: #{response.message}\n" \
                               "Response Body: #{response.body}"
                            else
                               "Response = nil"
                            end
              # ditto cyclic warning
              #$log.warn "Failed to #{req.method} #{uri}\n(#{res_summary})\n" \
              #   "Request Body: #{req.body}"
           end #end unless
        end # end begin
      end # end send_request
    
      def handle_record(tag, time, record)
        req, uri = create_request(tag, time, record)
        send_request(req, uri)
      end
    
      def emit(tag, es, chain)
        es.each do |time, record|
          handle_record(tag, time, record)
        end
        chain.next
      end
    end
  end
end

